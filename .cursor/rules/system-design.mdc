# System Design & Architecture Guidelines

## Microservices Architecture

### Service Decomposition
- **Domain-Based Services**: Organize services around business domains
- **Single Responsibility**: Each service should have one clear purpose
- **Bounded Contexts**: Define clear boundaries between services
- **Service Independence**: Services should be deployable independently
- **Data Ownership**: Each service owns its data and exposes APIs

### Service Communication
- **Synchronous**: HTTP/REST for request-response patterns
- **Asynchronous**: Message queues for event-driven communication
- **API Gateway**: Centralized routing and cross-cutting concerns
- **Service Discovery**: Dynamic service location and health checking
- **Load Balancing**: Distribute traffic across service instances

## API Design Patterns

### RESTful API Design
```csharp
[ApiController]
[Route("api/v1/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IMediator _mediator;
    
    public ProductsController(IMediator mediator)
    {
        _mediator = mediator;
    }
    
    [HttpGet]
    [ProducesResponseType(typeof(PaginatedResult<ProductDto>), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<IActionResult> GetProducts(
        [FromQuery] GetProductsQuery query,
        CancellationToken cancellationToken)
    {
        var result = await _mediator.Send(query, cancellationToken);
        return Ok(result);
    }
    
    [HttpPost]
    [ProducesResponseType(typeof(ProductDto), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    public async Task<IActionResult> CreateProduct(
        [FromBody] CreateProductCommand command,
        CancellationToken cancellationToken)
    {
        var productId = await _mediator.Send(command, cancellationToken);
        return CreatedAtAction(nameof(GetProduct), new { id = productId }, productId);
    }
}
```

### GraphQL API Design
```csharp
public class ProductType : ObjectType<Product>
{
    protected override void Configure(IObjectTypeDescriptor<Product> descriptor)
    {
        descriptor.Field(p => p.Id).Type<NonNullType<IdType>>();
        descriptor.Field(p => p.Name).Type<NonNullType<StringType>>();
        descriptor.Field(p => p.Price).Type<NonNullType<DecimalType>>();
        descriptor.Field(p => p.Categories).ResolveWith<ProductResolvers>(r => r.GetCategories(default!, default!));
    }
}

public class ProductResolvers
{
    public async Task<IEnumerable<Category>> GetCategories([Parent] Product product, [Service] ICategoryService categoryService)
    {
        return await categoryService.GetCategoriesForProductAsync(product.Id);
    }
}
```

### gRPC API Design
```protobuf
syntax = "proto3";

package TossErp.Products;

service ProductService {
  rpc GetProduct(GetProductRequest) returns (ProductResponse);
  rpc CreateProduct(CreateProductRequest) returns (ProductResponse);
  rpc UpdateProduct(UpdateProductRequest) returns (ProductResponse);
  rpc DeleteProduct(DeleteProductRequest) returns (DeleteProductResponse);
  rpc ListProducts(ListProductsRequest) returns (ListProductsResponse);
}

message Product {
  string id = 1;
  string name = 2;
  decimal price = 3;
  string currency = 4;
  repeated string categories = 5;
  ProductStatus status = 6;
  google.protobuf.Timestamp created_at = 7;
  google.protobuf.Timestamp updated_at = 8;
}

enum ProductStatus {
  PRODUCT_STATUS_UNSPECIFIED = 0;
  PRODUCT_STATUS_ACTIVE = 1;
  PRODUCT_STATUS_INACTIVE = 2;
  PRODUCT_STATUS_DISCONTINUED = 3;
}
```

## Event-Driven Architecture

### Event Sourcing
```csharp
public abstract class AggregateRoot
{
    private readonly List<IDomainEvent> _domainEvents = new();
    public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();
    
    protected void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }
    
    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }
}

public class ProductCreatedEvent : IDomainEvent
{
    public Guid ProductId { get; }
    public string ProductName { get; }
    public decimal Price { get; }
    public DateTime OccurredOn { get; }
    
    public ProductCreatedEvent(Guid productId, string productName, decimal price)
    {
        ProductId = productId;
        ProductName = productName;
        Price = price;
        OccurredOn = DateTime.UtcNow;
    }
}
```

### Event Store Implementation
```csharp
public interface IEventStore
{
    Task<IEnumerable<IDomainEvent>> GetEventsAsync(Guid aggregateId);
    Task SaveEventsAsync(Guid aggregateId, IEnumerable<IDomainEvent> events, int expectedVersion);
}

public class EventStore : IEventStore
{
    private readonly IEventSerializer _serializer;
    private readonly IEventPublisher _publisher;
    
    public async Task SaveEventsAsync(Guid aggregateId, IEnumerable<IDomainEvent> events, int expectedVersion)
    {
        var eventList = events.ToList();
        var version = expectedVersion;
        
        foreach (var @event in eventList)
        {
            version++;
            @event.Version = version;
            
            var eventData = _serializer.Serialize(@event);
            await StoreEventAsync(aggregateId, @event.GetType().Name, version, eventData);
        }
        
        await _publisher.PublishAsync(events);
    }
}
```

### Message Queuing
```csharp
public interface IMessageBus
{
    Task PublishAsync<T>(string topic, T message, CancellationToken cancellationToken = default);
    Task SubscribeAsync<T>(string topic, Func<T, Task> handler, CancellationToken cancellationToken = default);
}

public class RabbitMQMessageBus : IMessageBus
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    
    public async Task PublishAsync<T>(string topic, T message, CancellationToken cancellationToken = default)
    {
        var body = JsonSerializer.SerializeToUtf8Bytes(message);
        var properties = _channel.CreateBasicProperties();
        properties.Persistent = true;
        
        _channel.BasicPublish(
            exchange: "erp.events",
            routingKey: topic,
            basicProperties: properties,
            body: body);
    }
}
```

## Scalability Patterns

### Horizontal Scaling
- **Load Balancing**: Distribute traffic across multiple instances
- **Auto-scaling**: Automatically scale based on demand
- **Stateless Services**: Services should not maintain state between requests
- **Database Sharding**: Distribute data across multiple databases
- **Caching**: Implement multiple layers of caching

### Caching Strategies
```csharp
public class CachingService : ICachingService
{
    private readonly IDistributedCache _cache;
    private readonly ILogger<CachingService> _logger;
    
    public async Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default)
    {
        var cachedValue = await _cache.GetStringAsync(key, cancellationToken);
        if (cachedValue == null)
            return default;
            
        try
        {
            return JsonSerializer.Deserialize<T>(cachedValue);
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "Failed to deserialize cached value for key: {Key}", key);
            return default;
        }
    }
    
    public async Task SetAsync<T>(string key, T value, TimeSpan? expiration = null, CancellationToken cancellationToken = default)
    {
        var serializedValue = JsonSerializer.Serialize(value);
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = expiration ?? TimeSpan.FromMinutes(30)
        };
        
        await _cache.SetStringAsync(key, serializedValue, options, cancellationToken);
    }
}
```

### Database Patterns
```csharp
public class DatabaseShardingService : IDatabaseShardingService
{
    private readonly Dictionary<string, string> _shardConnections;
    private readonly IShardKeyResolver _shardKeyResolver;
    
    public string GetShardConnectionString(string shardKey)
    {
        var shardId = _shardKeyResolver.ResolveShardId(shardKey);
        return _shardConnections[shardId];
    }
    
    public async Task<T> ExecuteOnShardAsync<T>(string shardKey, Func<IDbConnection, Task<T>> operation)
    {
        var connectionString = GetShardConnectionString(shardKey);
        using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync();
        return await operation(connection);
    }
}
```

## Security Patterns

### Authentication & Authorization
```csharp
public class JwtAuthenticationHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    private readonly IJwtTokenValidator _tokenValidator;
    
    protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var token = GetTokenFromRequest();
        if (string.IsNullOrEmpty(token))
            return AuthenticateResult.Fail("Token not provided");
            
        try
        {
            var claimsPrincipal = await _tokenValidator.ValidateTokenAsync(token);
            var ticket = new AuthenticationTicket(claimsPrincipal, Scheme.Name);
            return AuthenticateResult.Success(ticket);
        }
        catch (Exception ex)
        {
            return AuthenticateResult.Fail($"Token validation failed: {ex.Message}");
        }
    }
}

[Authorize(Policy = "RequireAdminRole")]
public class AdminController : ControllerBase
{
    [HttpPost("users")]
    public async Task<IActionResult> CreateUser([FromBody] CreateUserCommand command)
    {
        // Implementation
    }
}
```

### API Security
```csharp
public class ApiKeyAuthenticationHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    private readonly IConfiguration _configuration;
    
    protected override async Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        if (!Request.Headers.ContainsKey("X-API-Key"))
            return AuthenticateResult.Fail("API key not provided");
            
        var apiKey = Request.Headers["X-API-Key"].FirstOrDefault();
        if (string.IsNullOrEmpty(apiKey))
            return AuthenticateResult.Fail("API key is empty");
            
        if (!IsValidApiKey(apiKey))
            return AuthenticateResult.Fail("Invalid API key");
            
        var claims = new[] { new Claim(ClaimTypes.Name, "API User") };
        var identity = new ClaimsIdentity(claims, Scheme.Name);
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, Scheme.Name);
        
        return AuthenticateResult.Success(ticket);
    }
}
```

## Monitoring & Observability

### Health Checks
```csharp
public class DatabaseHealthCheck : IHealthCheck
{
    private readonly IDbConnection _connection;
    
    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            await _connection.QueryAsync<int>("SELECT 1", cancellationToken: cancellationToken);
            return HealthCheckResult.Healthy("Database is accessible");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Database is not accessible", ex);
        }
    }
}

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddHealthChecks()
            .AddCheck<DatabaseHealthCheck>("database")
            .AddCheck<RedisHealthCheck>("redis")
            .AddCheck<ExternalApiHealthCheck>("external-api");
    }
    
    public void Configure(IApplicationBuilder app)
    {
        app.UseHealthChecks("/health", new HealthCheckOptions
        {
            ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
        });
    }
}
```

### Distributed Tracing
```csharp
public class TracingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<TracingMiddleware> _logger;
    
    public async Task InvokeAsync(HttpContext context)
    {
        var traceId = context.TraceIdentifier;
        var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault() ?? Guid.NewGuid().ToString();
        
        using var activity = ActivitySource.StartActivity("HTTP Request");
        activity?.SetTag("http.method", context.Request.Method);
        activity?.SetTag("http.url", context.Request.Path);
        activity?.SetTag("correlation.id", correlationId);
        
        context.Response.Headers["X-Correlation-ID"] = correlationId;
        context.Response.Headers["X-Trace-ID"] = traceId;
        
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            activity?.SetTag("error", true);
            activity?.SetTag("error.message", ex.Message);
            throw;
        }
    }
}
```

### Metrics Collection
```csharp
public class MetricsMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMetrics _metrics;
    
    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            await _next(context);
        }
        finally
        {
            stopwatch.Stop();
            
            var route = context.Request.Path.Value ?? "unknown";
            var method = context.Request.Method;
            var statusCode = context.Response.StatusCode;
            
            _metrics.RecordHttpRequest(route, method, statusCode, stopwatch.ElapsedMilliseconds);
        }
    }
}
```

## Deployment & Infrastructure

### Docker Configuration
```dockerfile
# Multi-stage build for .NET application
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY ["Services/Stock/Stock.API/Stock.API.csproj", "Services/Stock/Stock.API/"]
COPY ["Services/Stock/Stock.Application/Stock.Application.csproj", "Services/Stock/Stock.Application/"]
COPY ["Services/Stock/Stock.Domain/Stock.Domain.csproj", "Services/Stock/Stock.Domain/"]
COPY ["Services/Stock/Stock.Infrastructure/Stock.Infrastructure.csproj", "Services/Stock/Stock.Infrastructure/"]
RUN dotnet restore "Services/Stock/Stock.API/Stock.API.csproj"
COPY . .
WORKDIR "/src/Services/Stock/Stock.API"
RUN dotnet build "Stock.API.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "Stock.API.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "Stock.API.dll"]
```

### Kubernetes Configuration
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: stock-api
  namespace: tosserp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: stock-api
  template:
    metadata:
      labels:
        app: stock-api
    spec:
      containers:
      - name: stock-api
        image: tosserp/stock-api:latest
        ports:
        - containerPort: 80
        env:
        - name: ASPNETCORE_ENVIRONMENT
          value: "Production"
        - name: DATABASE_CONNECTION_STRING
          valueFrom:
            secretKeyRef:
              name: stock-db-secret
              key: connection-string
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health/live
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: stock-api-service
  namespace: tosserp
spec:
  selector:
    app: stock-api
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: stock-api-ingress
  namespace: tosserp
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: stock.tosserp.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: stock-api-service
            port:
              number: 80
```

## Performance Optimization

### Database Optimization
```csharp
public class OptimizedProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _context;
    private readonly IMemoryCache _cache;
    
    public async Task<IEnumerable<Product>> GetProductsWithCategoriesAsync(CancellationToken cancellationToken = default)
    {
        var cacheKey = "products_with_categories";
        
        if (_cache.TryGetValue(cacheKey, out IEnumerable<Product> cachedProducts))
            return cachedProducts;
        
        var products = await _context.Products
            .Include(p => p.Categories)
            .AsNoTracking()
            .ToListAsync(cancellationToken);
        
        var cacheOptions = new MemoryCacheEntryOptions()
            .SetSlidingExpiration(TimeSpan.FromMinutes(15))
            .SetAbsoluteExpiration(TimeSpan.FromHours(1));
        
        _cache.Set(cacheKey, products, cacheOptions);
        return products;
    }
}
```

### API Performance
```csharp
public class ProductController : ControllerBase
{
    [HttpGet]
    [ResponseCache(Duration = 300, Location = ResponseCacheLocation.Any)]
    public async Task<IActionResult> GetProducts([FromQuery] ProductQuery query)
    {
        // Implementation with caching
    }
    
    [HttpPost]
    [ProducesResponseType(StatusCodes.Status202Accepted)]
    public async Task<IActionResult> CreateProduct([FromBody] CreateProductCommand command)
    {
        // Queue the command for background processing
        await _commandBus.SendAsync(command);
        return Accepted();
    }
}
```

## Best Practices Summary

### Architecture Principles
- **Single Responsibility**: Each service has one clear purpose
- **Loose Coupling**: Services communicate through well-defined interfaces
- **High Cohesion**: Related functionality is grouped together
- **Fail Fast**: Detect and handle errors early
- **Graceful Degradation**: System continues to function with reduced capabilities

### Design Patterns
- **CQRS**: Separate read and write operations
- **Event Sourcing**: Store all changes as events
- **Saga Pattern**: Manage distributed transactions
- **Circuit Breaker**: Prevent cascading failures
- **Retry Pattern**: Handle transient failures

### Security Considerations
- **Defense in Depth**: Multiple layers of security
- **Principle of Least Privilege**: Minimal required permissions
- **Secure by Default**: Secure configurations by default
- **Input Validation**: Validate all inputs
- **Audit Logging**: Log all security-relevant events

### Performance Guidelines
- **Caching**: Implement multiple caching layers
- **Async Operations**: Use async/await for I/O operations
- **Connection Pooling**: Reuse database connections
- **Load Balancing**: Distribute load across instances
- **Monitoring**: Track performance metrics
description: Comprehensive system design guidelines for microservices architecture, API design, event-driven systems, and scalability patterns
globs: **/*.cs, **/*.yml, **/*.yaml, **/Dockerfile, **/docker-compose.*, **/kubernetes/**/*, **/infra/**/*
alwaysApply: true
---
