# TOSS ERP System Development Guidelines

## System Overview
TOSS is a cloud-native **ERP III + collaborative network + AI co-pilot** for South African township & rural SMMEs (TREP sectors).

## Core Principles
- **Front-end first**: Flutter 3.24+ mobile, Nuxt 4 web
- **Offline-first**: Full functionality without internet
- **Low data use**: Optimized for limited connectivity
- **Ultra-simple UX**: Intuitive interface for non-technical users
- **Modular microservices**: .NET 9 with Clean Architecture and DDD
- **Event-driven**: Asynchronous communication patterns with RabbitMQ
- **POPIA-compliant**: South African data protection compliance
- **Agentic AI**: Human-in-the-loop AI assistance with LangChain
- **Performance**: Latest framework optimizations and best practices

## Architecture Patterns

### 1. Clean Architecture (.NET 9)
```
Services/
  ServiceName/
    ServiceName.API/           # Presentation layer (Minimal APIs)
    ServiceName.Application/    # Application layer (CQRS, MediatR)
    ServiceName.Domain/         # Domain layer (DDD, Events)
    ServiceName.Infrastructure/ # Infrastructure layer (EF Core 9, Redis)
    ServiceName.Processor/      # Background services (Hosted Services)
```

### 2. Domain-Driven Design (DDD)
- **Aggregates**: Item, Warehouse, StockAdjustment, Customer, Order
- **Entities**: StockLevel, StockMovement, OrderItem
- **Value Objects**: Quantity, Money, SKU, MovementType, Address
- **Domain Events**: ItemCreated, StockReceived, OrderPlaced
- **Domain Services**: StockCalculationService, CostingService

### 3. CQRS Pattern
- **Commands**: CreateItem, UpdateItem, ReceiveStock, IssueStock
- **Queries**: GetItems, GetStockLevels, GetMovementHistory
- **Event Sourcing**: Complete audit trail for all changes
- **Read Models**: Optimized for reporting and analytics

### 4. Event-Driven Architecture
- **Event Bus**: MassTransit + RabbitMQ integration
- **Event Store**: PostgreSQL with event sourcing
- **Event Handlers**: Cross-service communication
- **Saga Pattern**: Long-running business processes

## Stock Module Implementation

### Core Entities
```csharp
public class Item : AggregateRoot
{
    public Guid Id { get; private set; }
    public Guid TenantId { get; private set; }
    public string SKU { get; private set; }
    public string? Barcode { get; private set; }
    public string Name { get; private set; }
    public string? Description { get; private set; }
    public string Category { get; private set; }
    public string Unit { get; private set; }
    public Money SellingPrice { get; private set; }
    public Money? CostPrice { get; private set; }
    public int ReorderLevel { get; private set; }
    public int ReorderQty { get; private set; }
    public bool IsActive { get; private set; }
    
    // Domain methods
    public void UpdateStock(int quantity, string reason)
    public void SetReorderLevel(int level)
    public void Deactivate()
}
```

### Value Objects
```csharp
public record Money(decimal Amount, string Currency = "ZAR")
{
    public static Money Zero => new(0);
    public static Money operator +(Money a, Money b) => new(a.Amount + b.Amount, a.Currency);
    public static Money operator -(Money a, Money b) => new(a.Amount - b.Amount, a.Currency);
}

public record Quantity(decimal Value, string Unit)
{
    public static Quantity operator +(Quantity a, Quantity b) => 
        a.Unit == b.Unit ? new(a.Value + b.Value, a.Unit) : throw new InvalidOperationException();
}
```

### Repository Pattern
```csharp
public interface IItemRepository
{
    Task<Item?> GetByIdAsync(Guid id, Guid tenantId);
    Task<IEnumerable<Item>> GetByCategoryAsync(string category, Guid tenantId);
    Task<Item?> GetBySkuAsync(string sku, Guid tenantId);
    Task AddAsync(Item item);
    Task UpdateAsync(Item item);
    Task<IEnumerable<Item>> GetLowStockItemsAsync(Guid tenantId);
}
```

## Offline-First Architecture

### Mobile (Flutter)
- **Local DB**: SQLite with sqflite
- **Sync Strategy**: Queue local changes with UUID + timestamp
- **Conflict Resolution**: Last-write-wins with manual override
- **Offline Capabilities**: Full CRUD, stock adjustments, reports

### Web (Nuxt 4)
- **State Management**: Pinia with persistence
- **Offline Detection**: Network status monitoring
- **Local Storage**: IndexedDB for large datasets
- **Service Worker**: Background sync, cache strategies

### Sync Protocol
```json
{
  "sync_batch": {
    "tenant_id": "t1",
    "device_id": "d1",
    "operations": [
      {
        "id": "uuid",
        "type": "create_item",
        "data": {...},
        "timestamp": "2024-01-20T10:00:00Z"
      }
    ]
  }
}
```

## AI Integration

### LangChain Workflows
- **Natural Language Queries**: "Show me low stock items"
- **Recommendation Engine**: Reorder suggestions based on ML
- **Anomaly Detection**: Unusual consumption patterns
- **Demand Forecasting**: Time-series analysis with external factors

### AI Agent Capabilities
- **Reorder Point Optimization**: ML model using sales velocity, lead time, seasonality
- **Smart Categorization**: Auto-suggest categories based on item names
- **Price Optimization**: Suggest selling prices based on cost and market
- **Automation**: Auto-purchase order generation (with approval)

## Security & Compliance

### Multi-Tenancy
- **Row-level Security**: All data filtered by TenantId
- **Isolation**: Complete separation between tenants
- **Audit Trail**: All changes logged with user and timestamp

### POPIA Compliance
- **Data Minimization**: Only collect necessary data
- **Consent Management**: Clear user consent for data processing
- **Data Portability**: Export user data on request
- **Right to Deletion**: Remove user data when requested

### Authentication & Authorization
- **JWT Tokens**: Secure API authentication
- **Role-based Access**: Owner, Manager, Clerk permissions
- **API Rate Limiting**: Prevent abuse and ensure fair usage

## Performance Requirements

### Response Times
- Item search: < 100ms for 10k items
- Stock adjustment: < 200ms including events
- Sync batch: < 5s for 100 operations
- Reports: < 2s for monthly data
- Real-time updates: < 500ms via SignalR

### Scalability
- **Horizontal Scaling**: Load balancing across service instances
- **Database Sharding**: Tenant-based data distribution
- **Caching Strategy**: Redis for frequently accessed data
- **Async Processing**: Background jobs for heavy operations

## Testing Strategy

### Unit Tests
- Domain logic: Stock calculations, validations
- Application services: Command/Query handlers
- Value objects: Quantity conversions, Money operations

### Integration Tests
- Repository operations with real database
- Event publishing/handling
- API endpoints with authentication
- Sync operations end-to-end

### E2E Tests
- Complete stock workflow
- Offline/online transitions
- Multi-tenant scenarios
- Performance under load

## Deployment & DevOps

### Containerization
- **Docker**: Multi-stage builds for optimized images
- **Kubernetes**: Orchestration, scaling, service mesh
- **Service Discovery**: Dynamic service location
- **Health Checks**: Proactive monitoring and restart

### CI/CD Pipeline
- **GitHub Actions**: Automated testing and deployment
- **Database Migrations**: Automated schema updates
- **Environment Management**: Dev, staging, production
- **Rollback Strategy**: Quick recovery from issues

### Monitoring & Observability
- **OpenTelemetry**: Distributed tracing and metrics
- **Health Endpoints**: Service health monitoring
- **Log Aggregation**: Centralized logging with correlation IDs
- **Alerting**: Proactive notification of issues

## Development Workflow

### 1. Feature Development
- Start with domain model and business rules
- Implement application layer with CQRS
- Add infrastructure layer (database, external services)
- Create API endpoints with validation
- Implement UI components (Flutter + Nuxt 4)
- Add comprehensive testing

### 2. Integration Points
- Define event contracts between services
- Implement event handlers for cross-service communication
- Add integration tests for event flows
- Monitor event processing performance

### 3. Offline Support
- Design local data models
- Implement sync queue mechanism
- Add conflict resolution logic
- Test offline scenarios thoroughly

### 4. AI Integration
- Define AI agent interfaces
- Implement LangChain workflows
- Add ML model integration
- Create feedback loops for improvement

## Best Practices

### Code Quality
- **Clean Code**: Readable, maintainable, testable
- **SOLID Principles**: Single responsibility, dependency inversion
- **Error Handling**: Graceful degradation and user feedback
- **Documentation**: Clear API documentation and code comments

### Performance
- **Async/Await**: Non-blocking operations throughout
- **Caching**: Strategic caching at multiple levels
- **Database Optimization**: Proper indexing and query optimization
- **Resource Management**: Efficient memory and CPU usage

### Security
- **Input Validation**: Validate all user inputs
- **SQL Injection Prevention**: Use parameterized queries
- **XSS Protection**: Sanitize user-generated content
- **CSRF Protection**: Anti-forgery tokens for forms

### Accessibility
- **WCAG Compliance**: Meet accessibility standards
- **Screen Reader Support**: Proper ARIA labels and descriptions
- **Keyboard Navigation**: Full keyboard accessibility
- **Color Contrast**: Sufficient contrast for readability

## Success Metrics

### Functional Requirements
- All CRUD operations working correctly
- Offline functionality with reliable sync
- AI recommendations generating with >70% accuracy
- Events flowing to other services correctly

### Performance Requirements
- Meet all response time requirements
- Handle concurrent users without degradation
- Sync operations complete within time limits
- Reports generate quickly for large datasets

### Quality Requirements
- >80% code coverage in tests
- All E2E tests passing
- No critical security vulnerabilities
- Comprehensive error handling and logging

### User Experience
- Intuitive interface for non-technical users
- Fast response times for all operations
- Reliable offline functionality
- Clear error messages and guidance
description: Comprehensive TOSS ERP system development guidelines for township and rural SMME management
globs: **/*.cs, **/*.vue, **/*.ts, **/*.dart, **/*.yaml, **/*.yml, **/*.json
alwaysApply: true
---
